import { drizzle } from "drizzle-orm/bun-sqlite";
import { drizzle as drizzlePg } from "drizzle-orm/node-postgres";
import { drizzle as drizzleMysql } from "drizzle-orm/mysql2";
import { migrate } from "drizzle-orm/bun-sqlite/migrator";
import { migrate as migratePg } from "drizzle-orm/node-postgres/migrator";
import { migrate as migrateMysql } from "drizzle-orm/mysql2/migrator";
import type { DatabaseProvider } from "@ccflare/config";
import type { DatabaseConnection } from "../providers/database-provider";
import { Logger } from "@ccflare/logger";
import { MigrationCompatibility } from "./migration-compatibility";
import * as schema from "../schema";
import { Database } from "bun:sqlite";
import { Client } from "pg";
import mysql from "mysql2/promise";
import path from "node:path";

const log = new Logger("DrizzleMigrations");

/**
 * Run Drizzle migrations for the specified database provider
 * This uses proper Drizzle migration files generated by drizzle-kit
 */
export async function runDrizzleMigrations(
	connection: DatabaseConnection,
	provider: DatabaseProvider
): Promise<void> {
	try {
		log.info(`Running Drizzle migrations for ${provider}`);

		switch (provider) {
			case 'sqlite': {
				await runSQLiteMigrations(connection);
				break;
			}

			case 'postgresql': {
				await runPostgreSQLMigrations(connection);
				break;
			}

			case 'mysql': {
				await runMySQLMigrations(connection);
				break;
			}

			default:
				throw new Error(`Unsupported database provider: ${provider}`);
		}

		log.info(`Drizzle migrations completed for ${provider}`);
	} catch (error) {
		log.error(`Failed to run Drizzle migrations for ${provider}:`, error);
		throw error;
	}
}

async function runSQLiteMigrations(connection: DatabaseConnection): Promise<void> {
	log.info("Running SQLite migrations using Drizzle migration files");

	// Check if we have a legacy schema that needs compatibility migrations
	const hasLegacy = await MigrationCompatibility.hasLegacySchema(connection, 'sqlite');

	if (hasLegacy) {
		log.info("Legacy schema detected, applying compatibility migrations");
		await MigrationCompatibility.applyLegacyMigrations(connection, 'sqlite');
	} else {
		log.info("No legacy schema detected, running Drizzle migrations");

		// Get the underlying SQLite database instance
		const sqliteProvider = connection as any;
		if (!sqliteProvider.db || typeof sqliteProvider.db.run !== 'function') {
			throw new Error("Invalid SQLite connection - missing database instance");
		}

		// Create Drizzle instance
		const db = drizzle(sqliteProvider.db, { schema });

		// Run migrations from generated files
		const migrationsFolder = path.join(__dirname, 'generated');
		await migrate(db, { migrationsFolder });

		log.info("Drizzle migrations completed successfully");
	}
}

async function runPostgreSQLMigrations(connection: DatabaseConnection): Promise<void> {
	log.info("Running PostgreSQL migrations using Drizzle migration files");

	try {
		// Get the underlying PostgreSQL client
		const pgProvider = connection as any;
		if (!pgProvider.client) {
			throw new Error("Invalid PostgreSQL connection - missing client instance");
		}

		// Create Drizzle instance
		const db = drizzlePg(pgProvider.client, { schema });

		// Run migrations from generated files
		const migrationsFolder = path.join(__dirname, 'generated-postgresql');
		await migratePg(db, { migrationsFolder });

		log.info("PostgreSQL Drizzle migrations completed successfully");
	} catch (error) {
		log.warn("PostgreSQL migration files not found, falling back to schema creation");
		await createPostgreSQLSchema(connection);
	}
}

async function runMySQLMigrations(connection: DatabaseConnection): Promise<void> {
	log.info("Running MySQL migrations using Drizzle migration files");

	try {
		// Get the underlying MySQL connection
		const mysqlProvider = connection as any;
		if (!mysqlProvider.connection) {
			throw new Error("Invalid MySQL connection - missing connection instance");
		}

		// Create Drizzle instance
		const db = drizzleMysql(mysqlProvider.connection, { schema, mode: "default" });

		// Run migrations from generated files
		const migrationsFolder = path.join(__dirname, 'generated-mysql');
		await migrateMysql(db, { migrationsFolder });

		log.info("MySQL Drizzle migrations completed successfully");
	} catch (error) {
		log.warn("MySQL migration files not found, falling back to schema creation");
		await createMySQLSchema(connection);
	}
}

/**
 * Create initial schema for the specified database provider
 * This is used when setting up a new database from scratch
 */
export async function createInitialSchema(
	connection: DatabaseConnection,
	provider: DatabaseProvider
): Promise<void> {
	log.info(`Creating initial schema for ${provider}`);

	try {
		// Use the migration system which will create schema if needed
		await runDrizzleMigrations(connection, provider);
		log.info(`Initial schema created successfully for ${provider}`);
	} catch (error) {
		log.error(`Failed to create initial schema for ${provider}:`, error);
		throw error;
	}
}

async function createSQLiteSchema(connection: DatabaseConnection): Promise<void> {
	log.error("createSQLiteSchema should not be called - use proper Drizzle migrations instead");
	throw new Error("Schema creation fallback should not be used for SQLite - use Drizzle migrations");
}

async function createPostgreSQLSchema(connection: DatabaseConnection): Promise<void> {
	log.warn("Using PostgreSQL schema creation fallback - consider generating proper migration files");

	// Get the underlying PostgreSQL client
	const pgProvider = connection as any;
	if (!pgProvider.client) {
		throw new Error("Invalid PostgreSQL connection - missing client instance");
	}

	// Create Drizzle instance and use it to create tables
	const db = drizzlePg(pgProvider.client, { schema });

	// For now, we'll use a simple approach - in production, generate proper migration files
	log.info("Creating PostgreSQL schema using Drizzle ORM");

	// This is a temporary fallback - proper migration files should be generated
	throw new Error("PostgreSQL schema creation fallback not yet implemented - generate proper migration files");
}

async function createMySQLSchema(connection: DatabaseConnection): Promise<void> {
	log.warn("Using MySQL schema creation fallback - consider generating proper migration files");

	// Get the underlying MySQL connection
	const mysqlProvider = connection as any;
	if (!mysqlProvider.connection) {
		throw new Error("Invalid MySQL connection - missing connection instance");
	}

	// Create Drizzle instance and use it to create tables
	const db = drizzleMysql(mysqlProvider.connection, { schema, mode: "default" });

	// For now, we'll use a simple approach - in production, generate proper migration files
	log.info("Creating MySQL schema using Drizzle ORM");

	// This is a temporary fallback - proper migration files should be generated
	throw new Error("MySQL schema creation fallback not yet implemented - generate proper migration files");
}


